<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MSNE Blog</title>
    <link>https://msne2016.github.io/tags/howto/index.xml</link>
    <description>Recent content on MSNE Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>MSNE All rights reserved.</copyright>
    <atom:link href="https://msne2016.github.io/tags/howto/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Contributing</title>
      <link>https://msne2016.github.io/post/example/</link>
      <pubDate>Tue, 20 Dec 2016 12:00:00 +0000</pubDate>
      
      <guid>https://msne2016.github.io/post/example/</guid>
      <description>

&lt;p&gt;This is a test page/playground with some examples on how to use the blog.&lt;/p&gt;

&lt;h2 id=&#34;rendering-latex&#34;&gt;Rendering Latex&lt;/h2&gt;

&lt;p&gt;Inline math like $21 \cdot 2 = 42$ is introduced with &lt;code&gt;$ ... $&lt;/code&gt;, while double signs &lt;code&gt;$$ ... $$&lt;/code&gt; create
a new paragraph containing the equation:&lt;/p&gt;

&lt;p&gt;$$
f(x) = \int_{x&amp;rsquo; \in \Omega} u(x&amp;rsquo;) k(x-x&amp;rsquo;) \text{d}x&amp;rsquo;
$$&lt;/p&gt;

&lt;p&gt;Since it is really annoying that using single &lt;code&gt;_&lt;/code&gt; signs in formulas are usually mistaken by markdown editors,
make sure to use &lt;code&gt;\_&lt;/code&gt; in latex formulas instead.&lt;/p&gt;

&lt;h2 id=&#34;inserting-code-snippets&#34;&gt;Inserting code snippets&lt;/h2&gt;

&lt;p&gt;Rendering code is of course also possible:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np
import matplotlib.pyplot as plt
import numpy as np
from numpy import ma
%matplotlib inline

ϵ = 0.1
b0 = 2.
b1 = 1.5

dudt = lambda U,W,I : U - U**3 / 3 - W + I
dwdt = lambda U,W : ϵ * (b0 + b1 * U - W)

def compute_trajectory(u0, w0, I, steps, dt):
    uu = [u0]
    ww = [w0]
    
    for t in range(steps):
        uu.append(uu[-1] + dudt(uu[-1], ww[-1], I) * dt)
        ww.append(ww[-1] + dwdt(uu[-1], ww[-1]) * dt)
        
    return np.array(uu), np.array(ww)

def trajectory_plot(I = 2):
    w_u0 = lambda u : (u - u**3 / 3 + I)
    u_u0 = lambda u : b0 + b1 * u

    U, W = np.meshgrid(np.arange(-3, 3, .5), np.arange(-3, 5, .5))
    dU = dudt(U,W,I)
    dW = dwdt(U,W)

    # Quiver Plot
    plt.figure()
    Q = plt.quiver(U,W,dU, dW, width=0.003, scale=100)
    qk = plt.quiverkey(Q, 0, 0, 3, r&#39;$\dot x$&#39;, labelpos=&#39;N&#39;,
                       fontproperties={&#39;weight&#39;: &#39;bold&#39;})
    l, r, b, t = plt.axis()
    dx, dy = r - l, t - b
    plt.axis([-3,3,-3,5])

    # Zero Lines
    uu = np.linspace(-3,3,100)
    plt.plot(uu, w_u0(uu))
    plt.plot(uu, u_u0(uu))

    # Trajectory
    uu, ww = compute_trajectory(-2,-2,I,10000,0.01)
    plt.plot(uu, ww)

    plt.xlabel(r&amp;quot;$u$&amp;quot;)
    plt.ylabel(r&amp;quot;$w$&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>